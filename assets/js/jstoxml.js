/*
    Copyright (c) 2020 by David Calhoun (david.b.calhoun@gmail.com).
    This source code is licensed under the MIT license found in the
    LICENSE file at
    https://github.com/davidcalhoun/jstoxml/blob/main/LICENSE.md
*/
const DATA_TYPES={ARRAY:'array',BOOLEAN:'boolean',DATE:'date',FUNCTION:'function',JSTOXML_OBJECT:'jstoxml-object',NULL:'null',NUMBER:'number',OBJECT:'object',STRING:'string'};const PRIMITIVE_TYPES=[DATA_TYPES.STRING,DATA_TYPES.NUMBER,DATA_TYPES.BOOLEAN];const DEFAULT_XML_HEADER='<?xml version="1.0" encoding="UTF-8"?>';const PRIVATE_VARS=['_selfCloseTag','_attrs'];const getIndentStr=(indent='',depth=0)=>indent.repeat(depth);const getType=(val)=>(Array.isArray(val)&&DATA_TYPES.ARRAY)||(typeof val===DATA_TYPES.OBJECT&&val!==null&&val._name&&DATA_TYPES.JSTOXML_OBJECT)||(val instanceof Date&&DATA_TYPES.DATE)||(val===null&&DATA_TYPES.NULL)||typeof val;const isCDATA=(str)=>str.startsWith('<![CDATA[');const mapStr=(input='',replacements={},contentMap)=>{let output=input;if(typeof input===DATA_TYPES.STRING){if(isCDATA(input)){return input}const regexp=new RegExp(`(${Object.keys(replacements).join('|')})(?!(\\w|#)*;)`,'g');output=String(input).replace(regexp,(str,entity)=>replacements[entity]||'')}return typeof contentMap==='function'?contentMap(output):output};const getAttributeKeyVals=(attributes={},replacements,filter,outputExplicitTrue)=>{const attributesArr=Array.isArray(attributes)?attributes:Object.entries(attributes).map(([key,val])=>{return{[key]:val}});return attributesArr.reduce((allAttributes,attr)=>{const key=Object.keys(attr)[0];const val=attr[key];if(typeof filter===DATA_TYPES.FUNCTION){const shouldFilterOut=filter(key,val);if(shouldFilterOut){return allAttributes}}const replacedVal=replacements?mapStr(val,replacements):val;const valStr=!outputExplicitTrue&&replacedVal===true?'':`="${replacedVal}"`;allAttributes.push(`${key}${valStr}`);return allAttributes},[])};const formatAttributes=(attributes={},replacements,filter,outputExplicitTrue)=>{const keyVals=getAttributeKeyVals(attributes,replacements,filter,outputExplicitTrue);if(keyVals.length===0)return'';const keysValsJoined=keyVals.join(' ');return`${keysValsJoined}`};const objToArray=(obj={})=>Object.keys(obj).map((key)=>{return{_name:key,_content:obj[key]}});const isPrimitive=(val)=>PRIMITIVE_TYPES.includes(getType(val));const isSimpleXML=(xmlStr)=>!xmlStr.match('<');const getHeaderString=({header,isOutputStart})=>{const shouldOutputHeader=header&&isOutputStart;if(!shouldOutputHeader)return'';const shouldUseDefaultHeader=typeof header===DATA_TYPES.BOOLEAN;return shouldUseDefaultHeader?DEFAULT_XML_HEADER:header};const defaultEntityReplacements={'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;'};export const toXML=(obj={},config={})=>{const{depth=0,indent,_isFirstItem,_isOutputStart=true,header,attributeReplacements:rawAttributeReplacements={},attributeFilter,attributeExplicitTrue=false,contentReplacements:rawContentReplacements={},contentMap,selfCloseTags=true}=config;const shouldTurnOffAttributeReplacements=typeof rawAttributeReplacements==='boolean'&&!rawAttributeReplacements;const attributeReplacements=shouldTurnOffAttributeReplacements?{}:{...defaultEntityReplacements,...rawAttributeReplacements};const shouldTurnOffContentReplacements=typeof rawContentReplacements==='boolean'&&!rawContentReplacements;const contentReplacements=shouldTurnOffContentReplacements?{}:{...defaultEntityReplacements,...rawContentReplacements};const indentStr=getIndentStr(indent,depth);const valType=getType(obj);const headerStr=getHeaderString({header,indent,depth,isOutputStart:_isOutputStart});const isOutputStart=_isOutputStart&&!headerStr&&_isFirstItem&&depth===0;const preIndentStr=indent&&!isOutputStart?'\n':'';let outputStr='';switch(valType){case DATA_TYPES.JSTOXML_OBJECT:{const{_name,_content}=obj;if(_content===null&&typeof contentMap!=='function'){outputStr=`${preIndentStr}${indentStr}${_name}`;break}const isArrayOfPrimitives=Array.isArray(_content)&&_content.every(isPrimitive);if(isArrayOfPrimitives){const primitives=_content.map((a)=>{return toXML({_name,_content:a},{...config,depth,_isOutputStart:false})});return primitives.join('')}if(PRIVATE_VARS.includes(_name))break;const newVal=toXML(_content,{...config,depth:depth+1,_isOutputStart:isOutputStart});const newValType=getType(newVal);const isNewValSimple=isSimpleXML(newVal);const isNewValCDATA=isCDATA(newVal);const preTag=`${preIndentStr}${indentStr}`;if(_name==='_comment'){outputStr+=`${preTag}<!--${_content}-->`;break}const valIsEmpty=newValType==='undefined'||newVal==='';const globalSelfClose=selfCloseTags;const localSelfClose=obj._selfCloseTag;const shouldSelfClose=typeof localSelfClose===DATA_TYPES.BOOLEAN?valIsEmpty&&localSelfClose:valIsEmpty&&globalSelfClose;const selfCloseStr=shouldSelfClose?'/':'';const attributesString=formatAttributes(obj._attrs,attributeReplacements,attributeFilter,attributeExplicitTrue);const tag=`<${_name}${attributesString}${selfCloseStr}>`;const preTagCloseStr=indent&&!isNewValSimple&&!isNewValCDATA?`\n${indentStr}`:'';const postTag=!shouldSelfClose?`${newVal}${preTagCloseStr}</${_name}>`:'';outputStr+=`${preTag}${tag}${postTag}`;break}case DATA_TYPES.OBJECT:{const keys=Object.keys(obj);const outputArr=keys.map((key,index)=>{const newConfig={...config,_isFirstItem:index===0,_isLastItem:index+1===keys.length,_isOutputStart:isOutputStart};const outputObj={_name:key};if(getType(obj[key])===DATA_TYPES.OBJECT){PRIVATE_VARS.forEach((privateVar)=>{const val=obj[key][privateVar];if(typeof val!=='undefined'){outputObj[privateVar]=val;delete obj[key][privateVar]}});const hasContent=typeof obj[key]._content!=='undefined';if(hasContent){if(Object.keys(obj[key]).length>1){const newContentObj=Object.assign({},obj[key]);delete newContentObj._content;outputObj._content=[...objToArray(newContentObj),obj[key]._content]}}}if(typeof outputObj._content==='undefined')outputObj._content=obj[key];const xml=toXML(outputObj,newConfig);return xml},config);outputStr=outputArr.join('');break}case DATA_TYPES.FUNCTION:{const fnResult=obj(config);outputStr=toXML(fnResult,config);break}case DATA_TYPES.ARRAY:{const outputArr=obj.map((singleVal,index)=>{const newConfig={...config,_isFirstItem:index===0,_isLastItem:index+1===obj.length,_isOutputStart:isOutputStart};return toXML(singleVal,newConfig)});outputStr=outputArr.join('');break}default:{outputStr=mapStr(obj,contentReplacements,contentMap);break}}return`${headerStr}${outputStr}`};export default{toXML};